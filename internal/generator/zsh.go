package generator

import (
	"fmt"
	"strings"

	"github.com/jvalentini/tabgen/internal/types"
)

// Zsh generates zsh completion scripts
type Zsh struct{}

// NewZsh creates a new Zsh generator
func NewZsh() *Zsh {
	return &Zsh{}
}

// GenerateWithLimits creates a zsh completion script with bounds checking
func (z *Zsh) GenerateWithLimits(tool *types.Tool) GenerateResult {
	// Apply truncation if needed
	truncatedTool, warnings := truncateTool(tool)

	// Generate the script
	script := z.Generate(truncatedTool)

	// Check output size
	script, sizeWarnings := checkOutputSize(script, tool.Name)
	warnings = append(warnings, sizeWarnings...)

	return GenerateResult{
		Script:   script,
		Warnings: warnings,
	}
}

// Generate creates a zsh completion script for a tool
func (z *Zsh) Generate(tool *types.Tool) string {
	var sb strings.Builder

	fmt.Fprintf(&sb, "#compdef %s\n", tool.Name)
	fmt.Fprintf(&sb, "# Zsh completion for %s\n", tool.Name)
	sb.WriteString("# Generated by TabGen\n\n")

	funcName := zshFuncName(tool.Name)

	fmt.Fprintf(&sb, "%s() {\n", funcName)
	sb.WriteString("    local curcontext=\"$curcontext\" state line\n")
	sb.WriteString("    typeset -A opt_args\n\n")

	// Build arguments spec
	sb.WriteString("    _arguments -C \\\n")

	// Global flags
	for _, flag := range tool.GlobalFlags {
		spec := z.formatFlagSpec(flag)
		if spec != "" {
			fmt.Fprintf(&sb, "        %s \\\n", spec)
		}
	}

	// Subcommands
	if len(tool.Subcommands) > 0 {
		sb.WriteString("        '1:command:->commands' \\\n")
		sb.WriteString("        '*::arg:->args'\n\n")

		sb.WriteString("    case $state in\n")
		sb.WriteString("        commands)\n")
		sb.WriteString("            local commands=(\n")
		for _, cmd := range tool.Subcommands {
			desc := escapeZshDesc(cmd.Description)
			if desc == "" {
				desc = cmd.Name
			}
			fmt.Fprintf(&sb, "                '%s:%s'\n", cmd.Name, desc)
			// Include aliases as completable names
			for _, alias := range cmd.Aliases {
				fmt.Fprintf(&sb, "                '%s:%s (alias for %s)'\n", alias, desc, cmd.Name)
			}
		}
		sb.WriteString("            )\n")
		sb.WriteString("            _describe 'command' commands\n")
		sb.WriteString("            ;;\n")

		sb.WriteString("        args)\n")
		sb.WriteString("            case $words[1] in\n")
		for _, cmd := range tool.Subcommands {
			z.generateZshSubcommandCase(&sb, cmd, true)
		}
		sb.WriteString("                *)\n")
		sb.WriteString("                    _files\n")
		sb.WriteString("                    ;;\n")
		sb.WriteString("            esac\n")
		sb.WriteString("            ;;\n")

		sb.WriteString("    esac\n")
	} else {
		sb.WriteString("        '*:file:_files'\n")
	}

	sb.WriteString("}\n\n")

	fmt.Fprintf(&sb, "%s \"$@\"\n", funcName)

	return sb.String()
}

// generateZshSubcommandCase generates a case entry for a subcommand
func (z *Zsh) generateZshSubcommandCase(sb *strings.Builder, cmd types.Command, includeAliases bool) {
	// Skip if no flags and no nested subcommands
	if len(cmd.Flags) == 0 && len(cmd.Subcommands) == 0 {
		return
	}

	// Build pattern matching name and aliases (e.g., "build|b")
	pattern := cmd.Name
	if includeAliases && len(cmd.Aliases) > 0 {
		pattern = cmd.Name + "|" + strings.Join(cmd.Aliases, "|")
	}
	fmt.Fprintf(sb, "                %s)\n", pattern)

	if len(cmd.Subcommands) > 0 {
		// Has nested subcommands
		sb.WriteString("                    case $words[2] in\n")
		for _, sub := range cmd.Subcommands {
			if len(sub.Flags) > 0 {
				// Build pattern matching name and aliases
				subPattern := sub.Name
				if len(sub.Aliases) > 0 {
					subPattern = sub.Name + "|" + strings.Join(sub.Aliases, "|")
				}
				fmt.Fprintf(sb, "                        %s)\n", subPattern)
				sb.WriteString("                            _arguments \\\n")
				for _, flag := range sub.Flags {
					spec := z.formatFlagSpec(flag)
					if spec != "" {
						fmt.Fprintf(sb, "                                %s \\\n", spec)
					}
				}
				sb.WriteString("                                '*:file:_files'\n")
				sb.WriteString("                            ;;\n")
			}
		}
		sb.WriteString("                        *)\n")
		// Complete nested subcommands
		sb.WriteString("                            local subcommands=(\n")
		for _, sub := range cmd.Subcommands {
			desc := escapeZshDesc(sub.Description)
			if desc == "" {
				desc = sub.Name
			}
			fmt.Fprintf(sb, "                                '%s:%s'\n", sub.Name, desc)
			// Include aliases
			for _, alias := range sub.Aliases {
				fmt.Fprintf(sb, "                                '%s:%s (alias for %s)'\n", alias, desc, sub.Name)
			}
		}
		sb.WriteString("                            )\n")
		sb.WriteString("                            _describe 'subcommand' subcommands\n")
		sb.WriteString("                            ;;\n")
		sb.WriteString("                    esac\n")
	} else {
		// Just flags
		sb.WriteString("                    _arguments \\\n")
		for _, flag := range cmd.Flags {
			spec := z.formatFlagSpec(flag)
			if spec != "" {
				fmt.Fprintf(sb, "                        %s \\\n", spec)
			}
		}
		sb.WriteString("                        '*:file:_files'\n")
	}
	sb.WriteString("                    ;;\n")
}

// escapeZshDesc escapes special characters in descriptions
func escapeZshDesc(desc string) string {
	desc = strings.ReplaceAll(desc, "'", "'\\''")
	desc = strings.ReplaceAll(desc, ":", "\\:")
	return desc
}

// formatFlagSpec creates a zsh _arguments spec for a flag
func (z *Zsh) formatFlagSpec(flag types.Flag) string {
	if flag.Name == "" && flag.Short == "" {
		return ""
	}

	desc := flag.Description
	if desc == "" {
		desc = flag.Name
	}
	// Escape special chars
	desc = strings.ReplaceAll(desc, "'", "'\\''")
	desc = strings.ReplaceAll(desc, "[", "\\[")
	desc = strings.ReplaceAll(desc, "]", "\\]")

	// Build argument completion part
	argCompletion := z.formatArgCompletion(flag)

	var spec string

	// Handle both short and long forms
	if flag.Short != "" && flag.Name != "" {
		// Both short and long
		if argCompletion != "" {
			spec = fmt.Sprintf("'(%s %s)'{%s,%s}'[%s]%s",
				flag.Short, flag.Name, flag.Short, flag.Name, desc, argCompletion)
		} else {
			spec = fmt.Sprintf("'(%s %s)'{%s,%s}'[%s]'",
				flag.Short, flag.Name, flag.Short, flag.Name, desc)
		}
	} else if flag.Name != "" {
		// Long only
		if argCompletion != "" {
			spec = fmt.Sprintf("'%s[%s]%s", flag.Name, desc, argCompletion)
		} else {
			spec = fmt.Sprintf("'%s[%s]'", flag.Name, desc)
		}
	} else {
		// Short only
		if argCompletion != "" {
			spec = fmt.Sprintf("'%s[%s]%s", flag.Short, desc, argCompletion)
		} else {
			spec = fmt.Sprintf("'%s[%s]'", flag.Short, desc)
		}
	}

	return spec
}

// formatArgCompletion builds the argument completion portion of a zsh spec
func (z *Zsh) formatArgCompletion(flag types.Flag) string {
	if flag.Arg == "" && len(flag.ArgumentValues) == 0 {
		return ""
	}

	argName := flag.Arg
	if argName == "" {
		argName = "value"
	}

	if len(flag.ArgumentValues) > 0 {
		// Use specific values: :arg:(val1 val2 val3)'
		values := strings.Join(flag.ArgumentValues, " ")
		return fmt.Sprintf(":%s:(%s)'", argName, values)
	}

	// No specific values, use generic arg placeholder: :arg:'
	return fmt.Sprintf(":%s:'", argName)
}

// zshFuncName creates a valid zsh function name from a tool name
func zshFuncName(name string) string {
	// Replace non-alphanumeric chars with underscore
	clean := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)
	return "_tabgen_" + clean
}
