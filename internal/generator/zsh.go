package generator

import (
	"fmt"
	"strings"

	"github.com/justin/tabgen/internal/types"
)

// Zsh generates zsh completion scripts
type Zsh struct{}

// NewZsh creates a new Zsh generator
func NewZsh() *Zsh {
	return &Zsh{}
}

// Generate creates a zsh completion script for a tool
func (z *Zsh) Generate(tool *types.Tool) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("#compdef %s\n", tool.Name))
	sb.WriteString(fmt.Sprintf("# Zsh completion for %s\n", tool.Name))
	sb.WriteString("# Generated by TabGen\n\n")

	funcName := zshFuncName(tool.Name)

	sb.WriteString(fmt.Sprintf("%s() {\n", funcName))
	sb.WriteString("    local curcontext=\"$curcontext\" state line\n")
	sb.WriteString("    typeset -A opt_args\n\n")

	// Build arguments spec
	sb.WriteString("    _arguments -C \\\n")

	// Global flags
	for _, flag := range tool.GlobalFlags {
		spec := z.formatFlagSpec(flag)
		if spec != "" {
			sb.WriteString(fmt.Sprintf("        %s \\\n", spec))
		}
	}

	// Subcommands
	if len(tool.Subcommands) > 0 {
		sb.WriteString("        '1:command:->commands' \\\n")
		sb.WriteString("        '*::arg:->args'\n\n")

		sb.WriteString("    case $state in\n")
		sb.WriteString("        commands)\n")
		sb.WriteString("            local commands=(\n")
		for _, cmd := range tool.Subcommands {
			desc := escapeZshDesc(cmd.Description)
			if desc == "" {
				desc = cmd.Name
			}
			sb.WriteString(fmt.Sprintf("                '%s:%s'\n", cmd.Name, desc))
		}
		sb.WriteString("            )\n")
		sb.WriteString("            _describe 'command' commands\n")
		sb.WriteString("            ;;\n")

		sb.WriteString("        args)\n")
		sb.WriteString("            case $words[1] in\n")
		for _, cmd := range tool.Subcommands {
			z.generateZshSubcommandCase(&sb, cmd)
		}
		sb.WriteString("                *)\n")
		sb.WriteString("                    _files\n")
		sb.WriteString("                    ;;\n")
		sb.WriteString("            esac\n")
		sb.WriteString("            ;;\n")

		sb.WriteString("    esac\n")
	} else {
		sb.WriteString("        '*:file:_files'\n")
	}

	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("%s \"$@\"\n", funcName))

	return sb.String()
}

// generateZshSubcommandCase generates a case entry for a subcommand
func (z *Zsh) generateZshSubcommandCase(sb *strings.Builder, cmd types.Command) {
	// Skip if no flags and no nested subcommands
	if len(cmd.Flags) == 0 && len(cmd.Subcommands) == 0 {
		return
	}

	sb.WriteString(fmt.Sprintf("                %s)\n", cmd.Name))

	if len(cmd.Subcommands) > 0 {
		// Has nested subcommands
		sb.WriteString("                    case $words[2] in\n")
		for _, sub := range cmd.Subcommands {
			if len(sub.Flags) > 0 {
				sb.WriteString(fmt.Sprintf("                        %s)\n", sub.Name))
				sb.WriteString("                            _arguments \\\n")
				for _, flag := range sub.Flags {
					spec := z.formatFlagSpec(flag)
					if spec != "" {
						sb.WriteString(fmt.Sprintf("                                %s \\\n", spec))
					}
				}
				sb.WriteString("                                '*:file:_files'\n")
				sb.WriteString("                            ;;\n")
			}
		}
		sb.WriteString("                        *)\n")
		// Complete nested subcommands
		sb.WriteString("                            local subcommands=(\n")
		for _, sub := range cmd.Subcommands {
			desc := escapeZshDesc(sub.Description)
			if desc == "" {
				desc = sub.Name
			}
			sb.WriteString(fmt.Sprintf("                                '%s:%s'\n", sub.Name, desc))
		}
		sb.WriteString("                            )\n")
		sb.WriteString("                            _describe 'subcommand' subcommands\n")
		sb.WriteString("                            ;;\n")
		sb.WriteString("                    esac\n")
	} else {
		// Just flags
		sb.WriteString("                    _arguments \\\n")
		for _, flag := range cmd.Flags {
			spec := z.formatFlagSpec(flag)
			if spec != "" {
				sb.WriteString(fmt.Sprintf("                        %s \\\n", spec))
			}
		}
		sb.WriteString("                        '*:file:_files'\n")
	}
	sb.WriteString("                    ;;\n")
}

// escapeZshDesc escapes special characters in descriptions
func escapeZshDesc(desc string) string {
	desc = strings.ReplaceAll(desc, "'", "'\\''")
	desc = strings.ReplaceAll(desc, ":", "\\:")
	return desc
}

// formatFlagSpec creates a zsh _arguments spec for a flag
func (z *Zsh) formatFlagSpec(flag types.Flag) string {
	if flag.Name == "" && flag.Short == "" {
		return ""
	}

	desc := flag.Description
	if desc == "" {
		desc = flag.Name
	}
	// Escape special chars
	desc = strings.ReplaceAll(desc, "'", "'\\''")
	desc = strings.ReplaceAll(desc, "[", "\\[")
	desc = strings.ReplaceAll(desc, "]", "\\]")

	var spec string

	// Handle both short and long forms
	if flag.Short != "" && flag.Name != "" {
		// Both short and long
		if flag.Arg != "" {
			spec = fmt.Sprintf("'(%s %s)'{%s,%s}'[%s]:%s:'",
				flag.Short, flag.Name, flag.Short, flag.Name, desc, flag.Arg)
		} else {
			spec = fmt.Sprintf("'(%s %s)'{%s,%s}'[%s]'",
				flag.Short, flag.Name, flag.Short, flag.Name, desc)
		}
	} else if flag.Name != "" {
		// Long only
		if flag.Arg != "" {
			spec = fmt.Sprintf("'%s[%s]:%s:'", flag.Name, desc, flag.Arg)
		} else {
			spec = fmt.Sprintf("'%s[%s]'", flag.Name, desc)
		}
	} else {
		// Short only
		if flag.Arg != "" {
			spec = fmt.Sprintf("'%s[%s]:%s:'", flag.Short, desc, flag.Arg)
		} else {
			spec = fmt.Sprintf("'%s[%s]'", flag.Short, desc)
		}
	}

	return spec
}

// zshFuncName creates a valid zsh function name from a tool name
func zshFuncName(name string) string {
	// Replace non-alphanumeric chars with underscore
	clean := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)
	return "_tabgen_" + clean
}
