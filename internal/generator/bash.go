package generator

import (
	"fmt"
	"strings"

	"github.com/justin/tabgen/internal/types"
)

// Bash generates bash completion scripts
type Bash struct{}

// NewBash creates a new Bash generator
func NewBash() *Bash {
	return &Bash{}
}

// Generate creates a bash completion script for a tool
func (b *Bash) Generate(tool *types.Tool) string {
	var sb strings.Builder

	funcName := bashFuncName(tool.Name)

	sb.WriteString(fmt.Sprintf("# Bash completion for %s\n", tool.Name))
	sb.WriteString("# Generated by TabGen\n\n")

	sb.WriteString(fmt.Sprintf("%s() {\n", funcName))
	sb.WriteString("    local cur prev words cword\n")
	sb.WriteString("    _init_completion || return\n\n")

	// Build list of subcommands (including aliases)
	if len(tool.Subcommands) > 0 {
		var cmds []string
		for _, cmd := range tool.Subcommands {
			cmds = append(cmds, cmd.Name)
			cmds = append(cmds, cmd.Aliases...)
		}
		sb.WriteString(fmt.Sprintf("    local commands=\"%s\"\n", strings.Join(cmds, " ")))
	}

	// Build list of global flags
	if len(tool.GlobalFlags) > 0 {
		flags := collectFlags(tool.GlobalFlags)
		sb.WriteString(fmt.Sprintf("    local flags=\"%s\"\n", strings.Join(flags, " ")))
	}

	sb.WriteString("\n")

	// Handle subcommand-specific completions
	if len(tool.Subcommands) > 0 {
		sb.WriteString("    # Find the current subcommand\n")
		sb.WriteString("    local cmd=\"\"\n")
		sb.WriteString("    local subcmd=\"\"\n")
		sb.WriteString("    for ((i=1; i < cword; i++)); do\n")
		sb.WriteString("        case \"${words[i]}\" in\n")
		sb.WriteString("            -*) ;;\n")
		sb.WriteString("            *)\n")
		sb.WriteString("                if [[ -z \"$cmd\" ]]; then\n")
		sb.WriteString("                    cmd=\"${words[i]}\"\n")
		sb.WriteString("                else\n")
		sb.WriteString("                    subcmd=\"${words[i]}\"\n")
		sb.WriteString("                    break\n")
		sb.WriteString("                fi\n")
		sb.WriteString("                ;;\n")
		sb.WriteString("        esac\n")
		sb.WriteString("    done\n\n")

		// Generate case statements for each subcommand
		sb.WriteString("    case \"$cmd\" in\n")
		for _, cmd := range tool.Subcommands {
			b.generateSubcommandCase(&sb, cmd, 2)
		}
		sb.WriteString("    esac\n\n")

		sb.WriteString("    # Top level: complete subcommands or flags\n")
		sb.WriteString("    if [[ -z \"$cmd\" ]]; then\n")
		sb.WriteString("        COMPREPLY=($(compgen -W \"$commands $flags\" -- \"$cur\"))\n")
		sb.WriteString("    fi\n")
	} else if len(tool.GlobalFlags) > 0 {
		// No subcommands, just flags
		sb.WriteString("    COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n")
	} else {
		// Fall back to file completion
		sb.WriteString("    COMPREPLY=($(compgen -f -- \"$cur\"))\n")
	}

	sb.WriteString("}\n\n")

	// Register completion with fallback behavior (side-by-side)
	sb.WriteString(fmt.Sprintf("complete -o default -o bashdefault -F %s %s\n", funcName, tool.Name))

	return sb.String()
}

// generateSubcommandCase generates a case entry for a subcommand
func (b *Bash) generateSubcommandCase(sb *strings.Builder, cmd types.Command, indent int) {
	prefix := strings.Repeat("    ", indent)

	// Build pattern matching name and aliases (e.g., "build|b")
	pattern := cmd.Name
	if len(cmd.Aliases) > 0 {
		pattern = cmd.Name + "|" + strings.Join(cmd.Aliases, "|")
	}
	sb.WriteString(fmt.Sprintf("%s%s)\n", prefix, pattern))

	// If this command has nested subcommands, handle them
	if len(cmd.Subcommands) > 0 {
		// Include aliases in the subcommand list
		var subcmds []string
		for _, sub := range cmd.Subcommands {
			subcmds = append(subcmds, sub.Name)
			subcmds = append(subcmds, sub.Aliases...)
		}

		sb.WriteString(fmt.Sprintf("%s    case \"$subcmd\" in\n", prefix))
		for _, sub := range cmd.Subcommands {
			if len(sub.Flags) > 0 {
				subFlags := collectFlags(sub.Flags)
				// Build pattern matching name and aliases
				subPattern := sub.Name
				if len(sub.Aliases) > 0 {
					subPattern = sub.Name + "|" + strings.Join(sub.Aliases, "|")
				}
				sb.WriteString(fmt.Sprintf("%s        %s)\n", prefix, subPattern))
				sb.WriteString(fmt.Sprintf("%s            COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", prefix, strings.Join(subFlags, " ")))
				sb.WriteString(fmt.Sprintf("%s            return\n", prefix))
				sb.WriteString(fmt.Sprintf("%s            ;;\n", prefix))
			}
		}
		sb.WriteString(fmt.Sprintf("%s    esac\n", prefix))

		// Complete nested subcommands
		if len(cmd.Flags) > 0 {
			cmdFlags := collectFlags(cmd.Flags)
			sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"%s %s\" -- \"$cur\"))\n", prefix, strings.Join(subcmds, " "), strings.Join(cmdFlags, " ")))
		} else {
			sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", prefix, strings.Join(subcmds, " ")))
		}
	} else if len(cmd.Flags) > 0 {
		// Just flags for this command
		cmdFlags := collectFlags(cmd.Flags)
		sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"%s $flags\" -- \"$cur\"))\n", prefix, strings.Join(cmdFlags, " ")))
	} else {
		sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n", prefix))
	}

	sb.WriteString(fmt.Sprintf("%s    return\n", prefix))
	sb.WriteString(fmt.Sprintf("%s    ;;\n", prefix))
}

// collectFlags extracts flag names from a slice of flags
func collectFlags(flags []types.Flag) []string {
	result := make([]string, 0, len(flags)*2)
	for _, flag := range flags {
		if flag.Name != "" {
			result = append(result, flag.Name)
		}
		if flag.Short != "" {
			result = append(result, flag.Short)
		}
	}
	return result
}

// bashFuncName creates a valid bash function name from a tool name
func bashFuncName(name string) string {
	// Replace non-alphanumeric chars with underscore
	clean := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)
	return "_tabgen_" + clean
}
