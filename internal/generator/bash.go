package generator

import (
	"fmt"
	"strings"

	"github.com/justin/tabgen/internal/types"
)

// Bash generates bash completion scripts
type Bash struct{}

// NewBash creates a new Bash generator
func NewBash() *Bash {
	return &Bash{}
}

// Generate creates a bash completion script for a tool
func (b *Bash) Generate(tool *types.Tool) string {
	var sb strings.Builder

	funcName := bashFuncName(tool.Name)

	sb.WriteString(fmt.Sprintf("# Bash completion for %s\n", tool.Name))
	sb.WriteString("# Generated by TabGen\n\n")

	sb.WriteString(fmt.Sprintf("%s() {\n", funcName))
	sb.WriteString("    local cur prev words cword\n")
	sb.WriteString("    _init_completion || return\n\n")

	// Build list of subcommands (including aliases)
	if len(tool.Subcommands) > 0 {
		var cmds []string
		for _, cmd := range tool.Subcommands {
			cmds = append(cmds, escapeShellString(cmd.Name))
			for _, alias := range cmd.Aliases {
				cmds = append(cmds, escapeShellString(alias))
			}
		}
		sb.WriteString(fmt.Sprintf("    local commands=\"%s\"\n", strings.Join(cmds, " ")))
	}

	// Build list of global flags
	if len(tool.GlobalFlags) > 0 {
		flags := collectFlags(tool.GlobalFlags)
		sb.WriteString(fmt.Sprintf("    local flags=\"%s\"\n", strings.Join(flags, " ")))
	}

	// Generate flag argument value completions
	b.generateFlagValueCompletions(&sb, tool.GlobalFlags, tool.Subcommands)

	sb.WriteString("\n")

	// Handle subcommand-specific completions
	if len(tool.Subcommands) > 0 {
		sb.WriteString("    # Find the current subcommand\n")
		sb.WriteString("    local cmd=\"\"\n")
		sb.WriteString("    local subcmd=\"\"\n")
		sb.WriteString("    for ((i=1; i < cword; i++)); do\n")
		sb.WriteString("        case \"${words[i]}\" in\n")
		sb.WriteString("            -*) ;;\n")
		sb.WriteString("            *)\n")
		sb.WriteString("                if [[ -z \"$cmd\" ]]; then\n")
		sb.WriteString("                    cmd=\"${words[i]}\"\n")
		sb.WriteString("                else\n")
		sb.WriteString("                    subcmd=\"${words[i]}\"\n")
		sb.WriteString("                    break\n")
		sb.WriteString("                fi\n")
		sb.WriteString("                ;;\n")
		sb.WriteString("        esac\n")
		sb.WriteString("    done\n\n")

		// Generate case statements for each subcommand
		sb.WriteString("    case \"$cmd\" in\n")
		for _, cmd := range tool.Subcommands {
			b.generateSubcommandCase(&sb, cmd, 2)
		}
		sb.WriteString("    esac\n\n")

		sb.WriteString("    # Top level: complete subcommands or flags\n")
		sb.WriteString("    if [[ -z \"$cmd\" ]]; then\n")
		sb.WriteString("        COMPREPLY=($(compgen -W \"$commands $flags\" -- \"$cur\"))\n")
		sb.WriteString("    fi\n")
	} else if len(tool.GlobalFlags) > 0 {
		// No subcommands, just flags
		sb.WriteString("    COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n")
	} else {
		// Fall back to file completion
		sb.WriteString("    COMPREPLY=($(compgen -f -- \"$cur\"))\n")
	}

	sb.WriteString("}\n\n")

	// Register completion with fallback behavior (side-by-side)
	sb.WriteString(fmt.Sprintf("complete -o default -o bashdefault -F %s %s\n", funcName, escapeShellString(tool.Name)))

	return sb.String()
}

// generateSubcommandCase generates a case entry for a subcommand
func (b *Bash) generateSubcommandCase(sb *strings.Builder, cmd types.Command, indent int) {
	prefix := strings.Repeat("    ", indent)

	// Build pattern matching name and aliases (e.g., "build|b")
	sb.WriteString(fmt.Sprintf("%s%s)\n", prefix, buildCasePattern(cmd.Name, cmd.Aliases)))

	// If this command has nested subcommands, handle them
	if len(cmd.Subcommands) > 0 {
		// Include aliases in the subcommand list
		var subcmds []string
		for _, sub := range cmd.Subcommands {
			subcmds = append(subcmds, escapeShellString(sub.Name))
			for _, alias := range sub.Aliases {
				subcmds = append(subcmds, escapeShellString(alias))
			}
		}

		sb.WriteString(fmt.Sprintf("%s    case \"$subcmd\" in\n", prefix))
		for _, sub := range cmd.Subcommands {
			if len(sub.Flags) > 0 {
				subFlags := collectFlags(sub.Flags)
				sb.WriteString(fmt.Sprintf("%s        %s)\n", prefix, buildCasePattern(sub.Name, sub.Aliases)))
				sb.WriteString(fmt.Sprintf("%s            COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", prefix, strings.Join(subFlags, " ")))
				sb.WriteString(fmt.Sprintf("%s            return\n", prefix))
				sb.WriteString(fmt.Sprintf("%s            ;;\n", prefix))
			}
		}
		sb.WriteString(fmt.Sprintf("%s    esac\n", prefix))

		// Complete nested subcommands
		if len(cmd.Flags) > 0 {
			cmdFlags := collectFlags(cmd.Flags)
			sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"%s %s\" -- \"$cur\"))\n", prefix, strings.Join(subcmds, " "), strings.Join(cmdFlags, " ")))
		} else {
			sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", prefix, strings.Join(subcmds, " ")))
		}
	} else if len(cmd.Flags) > 0 {
		// Just flags for this command
		cmdFlags := collectFlags(cmd.Flags)
		sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"%s $flags\" -- \"$cur\"))\n", prefix, strings.Join(cmdFlags, " ")))
	} else {
		sb.WriteString(fmt.Sprintf("%s    COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n", prefix))
	}

	sb.WriteString(fmt.Sprintf("%s    return\n", prefix))
	sb.WriteString(fmt.Sprintf("%s    ;;\n", prefix))
}

// collectFlags extracts flag names from a slice of flags
func collectFlags(flags []types.Flag) []string {
	result := make([]string, 0, len(flags)*2)
	for _, flag := range flags {
		if flag.Name != "" {
			result = append(result, escapeShellString(flag.Name))
		}
		if flag.Short != "" {
			result = append(result, escapeShellString(flag.Short))
		}
	}
	return result
}

// escapeShellString escapes characters special in double-quoted bash strings
func escapeShellString(s string) string {
	replacer := strings.NewReplacer(
		`\`, `\\`,
		`$`, `\$`,
		`"`, `\"`,
		"`", "\\`",
	)
	return replacer.Replace(s)
}

// escapeCasePattern escapes characters special in bash case patterns
func escapeCasePattern(s string) string {
	replacer := strings.NewReplacer(
		`\`, `\\`,
		`*`, `\*`,
		`?`, `\?`,
		`[`, `\[`,
		`]`, `\]`,
		`)`, `\)`,
	)
	return replacer.Replace(s)
}

// buildCasePattern creates a case pattern from name and aliases with proper escaping
func buildCasePattern(name string, aliases []string) string {
	parts := make([]string, 0, 1+len(aliases))
	parts = append(parts, escapeCasePattern(name))
	for _, alias := range aliases {
		parts = append(parts, escapeCasePattern(alias))
	}
	return strings.Join(parts, "|")
}

// bashFuncName creates a valid bash function name from a tool name
func bashFuncName(name string) string {
	// Replace non-alphanumeric chars with underscore
	clean := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)
	return "_tabgen_" + clean
}

// generateFlagValueCompletions generates case statements for flag argument values
func (b *Bash) generateFlagValueCompletions(sb *strings.Builder, globalFlags []types.Flag, subcommands []types.Command) {
	// Collect all flags with argument values
	flagValues := make(map[string][]string)

	for _, flag := range globalFlags {
		if len(flag.ArgumentValues) > 0 {
			if flag.Name != "" {
				flagValues[flag.Name] = flag.ArgumentValues
			}
			if flag.Short != "" {
				flagValues[flag.Short] = flag.ArgumentValues
			}
		}
	}

	// Also collect from subcommands
	var collectFromCommands func([]types.Command)
	collectFromCommands = func(cmds []types.Command) {
		for _, cmd := range cmds {
			for _, flag := range cmd.Flags {
				if len(flag.ArgumentValues) > 0 {
					if flag.Name != "" {
						flagValues[flag.Name] = flag.ArgumentValues
					}
					if flag.Short != "" {
						flagValues[flag.Short] = flag.ArgumentValues
					}
				}
			}
			if len(cmd.Subcommands) > 0 {
				collectFromCommands(cmd.Subcommands)
			}
		}
	}
	collectFromCommands(subcommands)

	if len(flagValues) == 0 {
		return
	}

	sb.WriteString("\n    # Handle flag argument value completions\n")
	sb.WriteString("    case \"$prev\" in\n")

	// Group flags by their values to reduce duplication
	valueGroups := make(map[string][]string)
	for flag, values := range flagValues {
		key := strings.Join(values, " ")
		valueGroups[key] = append(valueGroups[key], flag)
	}

	for values, flags := range valueGroups {
		// Escape each flag name for case pattern
		escapedFlags := make([]string, len(flags))
		for i, f := range flags {
			escapedFlags[i] = escapeCasePattern(f)
		}
		pattern := strings.Join(escapedFlags, "|")
		sb.WriteString(fmt.Sprintf("        %s)\n", pattern))
		// Escape values for double-quoted string
		sb.WriteString(fmt.Sprintf("            COMPREPLY=($(compgen -W \"%s\" -- \"$cur\"))\n", escapeShellString(values)))
		sb.WriteString("            return\n")
		sb.WriteString("            ;;\n")
	}

	sb.WriteString("    esac\n")
}
