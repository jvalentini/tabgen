package generator

import (
	"fmt"
	"strings"

	"github.com/justin/tabgen/internal/types"
)

// Bash generates bash completion scripts
type Bash struct{}

// NewBash creates a new Bash generator
func NewBash() *Bash {
	return &Bash{}
}

// Generate creates a bash completion script for a tool
func (b *Bash) Generate(tool *types.Tool) string {
	var sb strings.Builder

	funcName := bashFuncName(tool.Name)

	sb.WriteString(fmt.Sprintf("# Bash completion for %s\n", tool.Name))
	sb.WriteString(fmt.Sprintf("# Generated by TabGen\n\n"))

	sb.WriteString(fmt.Sprintf("%s() {\n", funcName))
	sb.WriteString("    local cur prev words cword\n")
	sb.WriteString("    _init_completion || return\n\n")

	// Build list of subcommands
	if len(tool.Subcommands) > 0 {
		cmds := make([]string, len(tool.Subcommands))
		for i, cmd := range tool.Subcommands {
			cmds[i] = cmd.Name
		}
		sb.WriteString(fmt.Sprintf("    local commands=\"%s\"\n", strings.Join(cmds, " ")))
	}

	// Build list of global flags
	if len(tool.GlobalFlags) > 0 {
		flags := make([]string, 0, len(tool.GlobalFlags)*2)
		for _, flag := range tool.GlobalFlags {
			if flag.Name != "" {
				flags = append(flags, flag.Name)
			}
			if flag.Short != "" {
				flags = append(flags, flag.Short)
			}
		}
		sb.WriteString(fmt.Sprintf("    local flags=\"%s\"\n", strings.Join(flags, " ")))
	}

	sb.WriteString("\n")

	// Handle subcommand-specific completions
	if len(tool.Subcommands) > 0 {
		sb.WriteString("    # Check if we're completing a subcommand\n")
		sb.WriteString("    local cmd_idx=1\n")
		sb.WriteString("    local cmd=\"\"\n")
		sb.WriteString("    for ((i=1; i < cword; i++)); do\n")
		sb.WriteString("        case \"${words[i]}\" in\n")
		sb.WriteString("            -*) ;;\n")
		sb.WriteString("            *)\n")
		sb.WriteString("                cmd=\"${words[i]}\"\n")
		sb.WriteString("                cmd_idx=$i\n")
		sb.WriteString("                break\n")
		sb.WriteString("                ;;\n")
		sb.WriteString("        esac\n")
		sb.WriteString("    done\n\n")

		sb.WriteString("    case \"$cmd\" in\n")
		for _, cmd := range tool.Subcommands {
			if len(cmd.Flags) > 0 || len(cmd.Subcommands) > 0 {
				sb.WriteString(fmt.Sprintf("        %s)\n", cmd.Name))

				// Subcommand flags
				if len(cmd.Flags) > 0 {
					cmdFlags := make([]string, 0, len(cmd.Flags)*2)
					for _, flag := range cmd.Flags {
						if flag.Name != "" {
							cmdFlags = append(cmdFlags, flag.Name)
						}
						if flag.Short != "" {
							cmdFlags = append(cmdFlags, flag.Short)
						}
					}
					sb.WriteString(fmt.Sprintf("            COMPREPLY=($(compgen -W \"%s $flags\" -- \"$cur\"))\n",
						strings.Join(cmdFlags, " ")))
				} else {
					sb.WriteString("            COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n")
				}
				sb.WriteString("            return\n")
				sb.WriteString("            ;;\n")
			}
		}
		sb.WriteString("    esac\n\n")

		sb.WriteString("    # Complete subcommands or flags at top level\n")
		sb.WriteString("    if [[ $cword -eq 1 ]]; then\n")
		sb.WriteString("        COMPREPLY=($(compgen -W \"$commands $flags\" -- \"$cur\"))\n")
		sb.WriteString("    else\n")
		sb.WriteString("        COMPREPLY=($(compgen -W \"$commands $flags\" -- \"$cur\"))\n")
		sb.WriteString("    fi\n")
	} else if len(tool.GlobalFlags) > 0 {
		// No subcommands, just flags
		sb.WriteString("    COMPREPLY=($(compgen -W \"$flags\" -- \"$cur\"))\n")
	} else {
		// Fall back to file completion
		sb.WriteString("    COMPREPLY=($(compgen -f -- \"$cur\"))\n")
	}

	sb.WriteString("}\n\n")

	// Register completion with fallback behavior (side-by-side)
	sb.WriteString(fmt.Sprintf("complete -o default -o bashdefault -F %s %s\n", funcName, tool.Name))

	return sb.String()
}

// bashFuncName creates a valid bash function name from a tool name
func bashFuncName(name string) string {
	// Replace non-alphanumeric chars with underscore
	clean := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, name)
	return "_tabgen_" + clean
}
